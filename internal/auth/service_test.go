package auth

import (
	"context"
	"fmt"
	"testing"

	"code-challenge/internal/entity"
	"code-challenge/pkg/log"

	"github.com/golang-jwt/jwt"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"gorm.io/gorm"
)

func TestService_Authenticate(t *testing.T) {
	mockJWTService := new(MockJWTService)
	mockRepo := new(MockRepo)
	logger := log.New()
	svc := NewService(mockRepo, mockJWTService, logger)

	t.Run("Authenticate success", func(t *testing.T) {
		ctx := context.Background()
		mockToken := "test_token"

		mockUser := &entity.User{ID: 100, Username: "test", Password: "$2a$10$hO/ynem0mJgn7zF7tYzeheydp7JEFPl3HrQcCzjmwSgjePjfJ/oEe"}
		mockRepo.On("GetByUsername", ctx, mock.Anything).Return(mockUser, nil).Once()
		mockJWTService.On("GenerateToken", mock.Anything).Return(mockToken, nil).Once()

		token, err := svc.Authenticate(ctx, "test", "123456")
		assert.NoErrorf(t, err, "expected no error but got: %v", err)
		assert.Equalf(t, mockToken, token, "expected token: %v but got token:  %v", mockToken, token)

		mockRepo.AssertExpectations(t)
		mockJWTService.AssertExpectations(t)
	})

	t.Run("Authenticate fails, user does not exist", func(t *testing.T) {
		ctx := context.Background()

		mockRepo.On("GetByUsername", ctx, mock.Anything).Return(nil, gorm.ErrRecordNotFound).Once()

		_, err := svc.Authenticate(ctx, "test", "123456")
		assert.Errorf(t, err, "expected error but got: %v", err)

		mockRepo.AssertExpectations(t)
	})

	t.Run("Authenticate fails, password is incorrect", func(t *testing.T) {
		ctx := context.Background()

		mockUser := &entity.User{ID: 100, Username: "test", Password: "incorrect"}
		mockRepo.On("GetByUsername", ctx, mock.Anything).Return(mockUser, nil).Once()

		_, err := svc.Authenticate(ctx, "test", "123456")
		errMsg := "incorrect username or password"
		assert.EqualErrorf(t, err, errMsg, "expected error: %v but got: %v", errMsg, err)

		mockRepo.AssertExpectations(t)
	})

	t.Run("Authenticate fails, failed to generate token", func(t *testing.T) {
		ctx := context.Background()

		mockUser := &entity.User{ID: 100, Username: "test", Password: "$2a$10$hO/ynem0mJgn7zF7tYzeheydp7JEFPl3HrQcCzjmwSgjePjfJ/oEe"}
		mockRepo.On("GetByUsername", ctx, mock.Anything).Return(mockUser, nil).Once()
		mockJWTService.On("GenerateToken", mock.Anything).Return("", fmt.Errorf("mock error")).Once()

		_, err := svc.Authenticate(ctx, "test", "123456")
		errMsg := "Failed to generate JWT"
		assert.EqualErrorf(t, err, errMsg, "expected error: %v but got: %v", errMsg, err)

		mockRepo.AssertExpectations(t)
	})

	t.Run("Authenticate fails, database connection issue", func(t *testing.T) {
		ctx := context.Background()

		mockRepo.On("GetByUsername", ctx, mock.Anything).Return(nil, fmt.Errorf("db error")).Once()

		_, err := svc.Authenticate(ctx, "test", "123456")
		errMsg := "We encountered an error while processing your request."
		assert.EqualErrorf(t, err, errMsg, "expected error: %v but got: %v", errMsg, err)

		mockRepo.AssertExpectations(t)
	})
}

// MockRepo is an autogenerated mock type for the repo type
type MockRepo struct {
	mock.Mock
}

// GetByUsername provides a mock function with given fields: ctx, username
func (_m *MockRepo) GetByUsername(ctx context.Context, username string) (*entity.User, error) {
	ret := _m.Called(ctx, username)

	var r0 *entity.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*entity.User, error)); ok {
		return rf(ctx, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.User); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type MockJWTService struct {
	mock.Mock
}

// GenerateToken provides a mock function with given fields: identity
func (_m *MockJWTService) GenerateToken(identity Identity) (string, error) {
	ret := _m.Called(identity)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(Identity) (string, error)); ok {
		return rf(identity)
	}
	if rf, ok := ret.Get(0).(func(Identity) string); ok {
		r0 = rf(identity)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(Identity) error); ok {
		r1 = rf(identity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateToken provides a mock function with given fields: authToken
func (_m *MockJWTService) ValidateToken(authToken string) (*jwt.Token, error) {
	ret := _m.Called(authToken)

	var r0 *jwt.Token
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*jwt.Token, error)); ok {
		return rf(authToken)
	}
	if rf, ok := ret.Get(0).(func(string) *jwt.Token); ok {
		r0 = rf(authToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jwt.Token)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(authToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
